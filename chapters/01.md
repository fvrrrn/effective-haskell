# Chapter 1
## Working with lists
If no step is present then 1 takes precedence:
```bash
λ [1..5]
[1,2,3,4,5]
```
If starting at the same value then list with this value:
```bash
λ [10..10]
[10]
```
If starting with a value that is larger than ending then:
```bash
λ [10..1]
[]
```
But if step is specified:
```bash
λ [10,9..0]
[10,9,8,7,6,5,4,3,2,1,0]
```

If step is specified then continue on with it:
```bash
λ [2,4..10]
[2,4,6,8,10]
```
If step is specified but last value is not included:
```bash
λ [0,23..100]
[0,23,46,69,92]
```
## Creating Lists with More Than One Type
In Haskell, a list can only contain one type of value at a time:
```bash
λ [1, "two"]
<interactive>:6:1: error:
• Ambiguous type variable ‘a0’ arising from a use of ‘print’
prevents the constraint ‘(Show a0)’ from being solved.
Probable fix: use a type annotation to specify what ‘a0’ should be.
These potential instances exist:
instance Show Ordering -- Defined in ‘GHC.Show’
instance Show Integer -- Defined in ‘GHC.Show’
instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
...plus 22 others
...plus 15 instances involving out-of-scope types
(use -fprint-potential-instances to see them all)
• In a stmt of an interactive GHCi command: print it
```
## Creating Pair
A list can hold any number of values, but they all have to be the same type. A tuple can hold different types of values, but size is fixed. You can’t add or remove items from a tuple.
```bash
λ quadruple = (4, "quadruple", 4.0, False)
```

## Printing Things to the Screen
Calling a function (or as we often say in Haskell, applying a function to some arguments) is as simple as functionName arg1 arg2 arg3. If you try to use putStrLn to print a number to the screen you’ll get another type error, since it only works with strings. Pick your favorite number and try passing it to putStrLn to see an example of this.
```bash
putStrLn 1
<interactive>:1:10: error:
    • No instance for (Num String) arising from the literal ‘1’
    • In the first argument of ‘putStrLn’, namely ‘1’
      In the expression: putStrLn 1
      In an equation for ‘it’: it = putStrLn 1
putStrLn (show 1)
print 1
```

## Writing Your First Haskell Program
```haskell
module Main where
main = print "Hello, World!"
```
```bash
user@host$ ghc Main
[1 of 1] Compiling Main ( Main.hs, Main.o )
Linking Main ...
user@host$ ./Main
"Hello, World!"
```
Or if you just want to quickly run it while developing:
```bash
user@host$ runhaskell Main.hs
"Hello, World!"
```
Or from interactive mode:
```bash
λ :load Main.hs
λ main
"Hello, World!"
```

## Formatting Haskell Code
`ormolu` or `fourmolu` (stayed with `formolu` as neovim's none-ls (null-ls) only supports it)

## Creating New Variables
```haskell
helloWorld = "Hello, World"
number5 = 5
snake_case_variable = True
number5' = 6
```

In this example, we are re-using the variable name greeting, but we are not changing the value of the variable. This can be a subtle distinction.
> GHCi specific
```bash
λ one = 1
λ two = one + one
λ one = 3
λ two
2
λ one
3
```
But
```haskell
one = 1
one = 2
Multiple declarations of 'one'
```
And be wary of below resulting in a recursion error. This is a common bug that causes problems for people first learning Haskell, and occasionally even catches experienced Haskellers off guard. The problem is, since all of our variables in Haskell are immutable, we can’t actually modify two to increment it. Instead, when we say two = two + 1 we’re creating a brand new variable named two, and its definition is recursive. The two on the right hand side of the expression is referring to the brand new two that we just defined. We have essentially just asked ghci to count forever. Since Haskell is a lazy language, it doesn’t actually try to run this infinitely recursive code until we ask it to print out the value of two.
```bash
two = 2
two = two + 1
```

To join string and lists use `++` or its more generic version `<>`
```haskell
module Main where
salutation = "Hello"
person = "George"
greeting =
salutation <> " " <> person
main = print greeting
```

## Writing Functions
```haskell
module Main where
-- Named
makeGreeting salutation person =
salutation <> " " <> person
main = print "no salutation to show yet"
-- Anonymous
\salutation person -> salutation <> " " <> person
```

Function parameters are available in inner scope as well:
```haskell
makeThruple a b c = (a,b,c)
lambdaThruple a b = \c -> (a,b,c)
lambdaThruple' = \a -> \b -> \c -> (a,b,c)
```
In fact, in Haskell all functions only take a single argument. Functions that appear to take multiple arguments, like makeThruple and lambdaThruple are really just shorthand for a function like lambdaThruple' that creates a new function for each parameter. The process of converting a function that takes multiple arguments into a series of single-argument functions is called currying. Although many languages support some form of currying, Haskell is somewhat unusual in the fact that all functions are curried by default. As you’ll see later in this section, and throughout this chapter, automatic currying makes some common Haskell idioms much easier to use.

When a function is called with all of its arguments and can return a value that isn’t a function, we call it `fully saturated`. It’s also possible, and common, to call a function with only some of its arguments. We say these functions are `partially applied`. The process of adding or removing those extra parameters has a name that you’ll sometimes see used in Haskell. Removing the extra parameter, as in the first example, is called eta reduction or η-reduction. Adding a parameter and passing it along is called eta expansion.
```haskell
greetPerson = makeGreeting "Hello"
greetPerson "George" -- "Hello George"
-- eta reduce:
enthusiasticGreeting salutation = <
makeGreeting (salutation <> "!")  |
          second parameter V------^
-- or eta expand:
enthusiasticGreeting salutation name =
makeGreeting (salutation <> "!") name
```

Operators, like (*) and (<>), are just functions that are infix by default. You can partially apply them like any other function, except that you need to put parentheses around the expression.
```bash
λ half = (/2)
λ twoOver = (2/)
λ half 10
λ half 20
λ twoOver 2
λ twoOver 8
λ greetGeorge = (`makeGreeting` "George")
λ greetGeorge "Hello"
λ greetGeorge "Good Evening"
```
You can use flip in the same place that you’d backticks:
```bash
λ greetGeorge = flip makeGreeting "George"
λ greetGeorge "Good Afternoon"
```

You might notice that when you write flip makeGreeting "George" that makeGreeting is applied to flip first, and then "George" is passed in to the resulting function. That is because of the precedence of function application. In Haskell, function application has a higher precedence, and it associates left to right, so flip makeGreeting "George" is the same as writing (flip makeGreeting) "George". Sometimes the precedence of function application will require you to use parentheses. For example, imagine a function that combines three strings:
```bash
λ sayThree a b c = a <> " " <> b <> " " <> c
```
```bash
λ flip sayThree "Good" "Afternoon" "George"
"Afternoon Good George"
```
```bash
λ flip sayThree "Good" "Afternoon" "George"
"Afternoon Good George"
```

```bash
λ flip (sayThree "Good") "Afternoon" "George"
"Good George Afternoon"
```

## Composing functions
If you want to use an output from function timesTwo as input in function addOne, this won't work:
```bash
λ addOne timesTwo 1
<interactive>:36:1: error:
• Non type-variable argument in the constraint: Num (a -> a)
(Use FlexibleContexts to permit this)
• When checking the inferred type
it :: forall {a}. (Num a, Num (a -> a)) => a
```
Because Haskell interprets it as apply function addOne to arguments timesTwo and `1`, and addOne signature expects only one Int parameter. But this will:
```bash
λ addOne (timesTwo 1)
<interactive>:36:1: error:
• Non type-variable argument in the constraint: Num (a -> a)
(Use FlexibleContexts to permit this)
• When checking the inferred type
it :: forall {a}. (Num a, Num (a -> a)) => a
```
And also with function application operator, ($), that helps us avoid having too many parentheses when we write code:
```haskell
addOne $ timesTwo 1
```

The function composition operator, (.), helps us quickly build new functions by combining existing ones. This operator is a higher-order function, a term you’ll hear used from time to time to describe functions that accept another function as an argument, or return a function. The (.) operator does both. It combines two functions and gives you a new function that accepts an argument to the right-hand function, and passes that function’s output on as input to the left-hand function. It’s a simple function that you could easily write yourself:
```haskell
(.) func1 func2 = \arg -> func1 (func2 arg)
timesTwoPlusOne = timesTwo . addOne -- right-to-left
```
Another example:
```bash
λ (timesTwo . addOne . squared . minusFive) 128
30260
```
But if applied without parentheses error happens because function application has higher precedence than (.) so this operator tries to combine not function but a function and a result of a function:
```bash
λ timesTwo . timesTwo 3
-- timesTwo . 6
<interactive>:34:1: error:
• Non type-variable argument in the constraint: Num (a -> c)
(Use FlexibleContexts to permit this)
• When checking the inferred type
it :: forall {c} {a}. (Num c, Num (a -> c)) => a -> c
```
## Writing Functions with No Named Parameters
Pointfree programming, sometimes called tacit programming, takes the ideas of η-reduction and function composition to their logical conclusion by writing functions that take no named parameters at all. For example, consider our original makeGreeting function:
```haskell
makeGreeting salutation person = salutation <> " " <> person
makeGreeting' salutation = ((salutation <> " ") <>)
makeGreeting'' salutation = (<>) (salutation <> " ") -- (<>) changes function call from infix to prefix so (<>) "abc" "def" -> "abcdef"
makeGreeting''' = (<>) . (\salutation -> salutation <> " ") -- join function application with string
firstPart salutation = salutation <> " "
makeGreeting'''' = (<>) . firstPart
makeGreeting''''' = (<>) . (<> " ")
-- 1. Execute (<> "1") "abc" -> "abc1"
-- 2. Execute (<>) to join the result
```

## Precedence, Operators, and Fixity /ˈfɪk.sə.t̬i/
```haskell
add add 1 2 add 3 4
<interactive>:123:1: error:
• Non type-variable argument in the constraint: Num (a -> a -> a)
(Use FlexibleContexts to permit this)
• When checking the inferred type
it :: forall {a}.
(Num a, Num (a -> a -> a),
Num ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a)) => a
-- But
add (add 1 2) (add 3 4) -- 10
```
Our original statement:
```haskell
add add 1 2 add 3 4
-- Becomes:
((((((add add) 1) 2) add) 3) 4) -- left associative
(add ((add 1 2) (add 3 4))) -- right associative
```
The choice of whether to parse things left-to-right or right-to-left is known as its associativity. We would say that our first example is left associative and the second example is right associative. Normal function application in Haskell is left associative. Infix functions and operators have a bit more flexibility.

We can’t control the binding precedence or associativity of normal function application in Haskell, but we can configure these for infix functions. This combination of properties is called its fixity, and we declare it using a fixity declaration. You’re most likely to see fixity declarations when creating custom operators.
