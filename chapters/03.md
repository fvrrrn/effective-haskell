# Chapter 2

## Working Haskell Types

```haskell
p :: Float
p = 3.14

p = 3.14 :: Float

λ :type x

addOne :: Int -> Int
addOne = (+ 1)
```

What about functions that take multiple arguments? Let’s take a look at an example first, and then pick apart why it works:

```haskell
addThreeNumbers :: Int -> (Int -> (Int -> Int))
addThreeNumbers a b c = a + b + c
```

This is because:

```haskell
addThreeNumbers = \a -> \b -> \c -> a + b + c
addThreeNumbers x y z =
  let
    f :: Int -> (Int -> (Int -> Int))
    f a =
      let
        g :: Int -> (Int -> Int)
        g b =
          let
            h :: Int -> Int
            h c = a + b + c
           in
            h
       in
        g
   in
    f x y z
-- in ((f x) y) z
```

Just like function application at the value level, we can usually drop the extra parentheses when we’re writing types for Haskell functions. Unlike function application, function types are right associative, so instead of Int -> (Int -> Int) we can write Int -> Int -> Int. In the case of addThreeNumbers, we can drop all of our parentheses and simply write:

```haskell
addThreeNumbers :: Int -> Int -> Int -> Int
```
