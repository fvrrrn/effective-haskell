# Chapter 2
## Writing Code Using Lists
### Operators:
1. `<>` ex. `[1, 2] <> [3, 4] == [1, 2, 3, 4]` join lists (as well as strings as they are lists of chars)
2. `!!` ex. `[1, 2] !! 0 == 1` get element at index
3. `:` (cons or construct) ex. `1 : [2, 3] == [1, 2, 3]` creates new list and adds element to the beginning
### Functions
1. `head` ex. `head [1, 2, 3] == 1` returns the first element of a list
2. `tail` ex. `tail [1, 2, 3] == [2, 3]` returns all elements starting with index 1 or without head
`head : tail = head : (head : (head : ... : []))`

## Creating Lists Recursively
Example of creating a list [n, n-1, n-2, ..., 1]:
```haskell
countdown n =
  if n <= 0
    then []
    else n : countdown (n - 1)
```

Example of a function that creates a list of prime factors of a number (prime factor is a zero-remainder prime denominator, ex. number = 8, prime factors 2, 2, 2 or number = 33, prime factors 3, 11):
```haskell
factors num =
  factors' num 2
 where
  factors' num fact
    | num == 1 = []
    | (num `rem` fact) == 0 = fact : factors' (num `div` fact) fact
    | otherwise = factors' num (fact + 1)
```

## Deconstructing Lists
Example of a bracket matcher:
```haskell
module P0020 where

isBalanced :: String -> Bool
isBalanced s =
  isBalanced' [] s
  where
    isBalanced' stack s
      | null s = null stack
      | isOpeningBracket (head s) = isBalanced' (matchBracket (head s) : stack) (tail s)
      | null stack = False
      | matchBracket (head s) == head stack = isBalanced' (tail stack) (tail s)
      | otherwise = False
      where
        matchBracket bracket
          | bracket == "(" = ")"
          | bracket == "[" = "]"
          | bracket == "{" = "}"
        isOpeningBracket bracket
          | bracket == "(" = True
          | bracket == "[" = True
          | bracket == "{" = True
          | otherwise = False
```

Example of `reduce` function is actually already available in `Prelude`, where it’s called `foldl`. The general term in Haskell for these functions that accumulate a value while recursing through a structure are called `folds`.
```haskell
reduce func carryValue lst =
  if null lst
    then carryValue
    else
      let intermediateValue = func carryValue (head lst)
       in reduce func intermediateValue (tail lst)
-- or
foldl func carryValue lst =
  if null lst
    then carryValue
    else foldl func (func carryValue (head lst)) (tail lst)

foldr func carryValue lst =
  if null lst
    then carryValue
    else func (head lst) $ foldr func carryValue (tail lst)
```

When we’re using folds, the operation that we’re passing in is treated as a normal function, and its associativity doesn’t impact the final result we get back. The associativity of the operation comes from the fold itself, rather than the function we pass in. You can see, for example, that we get the same result back from a call to foldl regardless of which division function we pass in:
```haskell
λ foldl (/) 1 [1,2,3,4,5]
8.333333333333333e-3
λ foldl divide 1 [1,2,3,4,5]
8.333333333333333e-3

λ foldr (/) 1 [1,2,3,4,5]
1.875
λ foldr divide 1 [1,2,3,4,5]
1.875
```

```haskell
λ foldr divide 1 [2,3,4,5]
0.5333333333333333
λ 1 `divide` 2 `divide` 3 `divide` 4 `divide` 5
1.875
-- because
2 `divide` 3 `divide` 4 `divide` 5 `divide` 1 -- is what foldr does
```

1. The l in foldl stands for left associative.
2. In a left fold, the initial value is applied first, at the left-hand side of the unrolled expression.
3. In a left fold the accumulator value is the first (left) argument of the function you pass in.
4. The r in foldr stands for right associative.
5. In a right fold, the initial value is applied last, at the right-hand side of an unrolled expression.
6. In a right fold, the accumulator is the second (right) argument of the function that you pass in.

## Transforming List Elements
Example of applying `map` function to a list:
```haskell
λ let incr x = x + 1 in map incr [1..3]
[2,3,4]
λ map (+ 2) [1..3]
[3,4,5]
λ map ($ 10) [(+ 1), (* 3), (`div` 5)]
[11,30,2]
```
Example of custom map function:
```haskell
doubleElements :: [Int] -> [Int]
doubleElements nums =
  if null nums
    then []
    else
      let
        hd = head nums
        tl = tail nums
       in
        (2 * hd) : doubleElements tl

doubleElements' numbers = foldr doubleElement [] where doubleElement number lst = (number * 2) : lst

doubleElements'' elems = foldr (applyElem (* 2)) [] elems
 where
  applyElem f elem accumulator = f elem : accumulator

map' f = foldr (applyElem f) []
 where
  applyElem f elem accumulator = (f elem) : accumulator
doubleElements''' elems = map' (* 2) elems

map'' f xs =
  if null xs
    then []
    else f (head xs) : map'' f (tail xs)
```
