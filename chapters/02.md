# Chapter 2
## Writing Code Using Lists
### Operators:
1. `<>` ex. `[1, 2] <> [3, 4] == [1, 2, 3, 4]` join lists (as well as strings as they are lists of chars)
2. `!!` ex. `[1, 2] !! 0 == 1` get element at index
3. `:` (cons or construct) ex. `1 : [2, 3] == [1, 2, 3]` creates new list and adds element to the beginning
### Functions
1. `head` ex. `head [1, 2, 3] == 1` returns the first element of a list
2. `tail` ex. `tail [1, 2, 3] == [2, 3]` returns all elements starting with index 1 or without head
`head : tail = head : (head : (head : ... : []))`

## Creating Lists Recursively
Example of creating a list [n, n-1, n-2, ..., 1]:
```haskell
countdown n =
  if n <= 0
    then []
    else n : countdown (n - 1)
```

Example of a function that creates a list of prime factors of a number (prime factor is a zero-remainder prime denominator, ex. number = 8, prime factors 2, 2, 2 or number = 33, prime factors 3, 11):
```haskell
factors num =
  factors' num 2
 where
  factors' num fact
    | num == 1 = []
    | (num `rem` fact) == 0 = fact : factors' (num `div` fact) fact
    | otherwise = factors' num (fact + 1)
```

## Deconstructing Lists
Example of a bracket matcher:
```haskell
module P0020 where

isBalanced :: String -> Bool
isBalanced s =
  isBalanced' [] s
  where
    isBalanced' stack s
      | null s = null stack
      | isOpeningBracket (head s) = isBalanced' (matchBracket (head s) : stack) (tail s)
      | null stack = False
      | matchBracket (head s) == head stack = isBalanced' (tail stack) (tail s)
      | otherwise = False
      where
        matchBracket bracket
          | bracket == "(" = ")"
          | bracket == "[" = "]"
          | bracket == "{" = "}"
        isOpeningBracket bracket
          | bracket == "(" = True
          | bracket == "[" = True
          | bracket == "{" = True
          | otherwise = False
```

Example of `reduce` function is actually already available in `Prelude`, where it’s called `foldl`. The general term in Haskell for these functions that accumulate a value while recursing through a structure are called `folds`.
```haskell
reduce func carryValue lst =
  if null lst
    then carryValue
    else
      let intermediateValue = func carryValue (head lst)
       in reduce func intermediateValue (tail lst)
-- or
foldl func carryValue lst =
  if null lst
    then carryValue
    else foldl func (func carryValue (head lst)) (tail lst)

foldr func carryValue lst =
  if null lst
    then carryValue
    else func (head lst) $ foldr func carryValue (tail lst)
```

When we’re using folds, the operation that we’re passing in is treated as a normal function, and its associativity doesn’t impact the final result we get back. The associativity of the operation comes from the fold itself, rather than the function we pass in. You can see, for example, that we get the same result back from a call to foldl regardless of which division function we pass in:
```haskell
λ foldl (/) 1 [1,2,3,4,5]
8.333333333333333e-3
λ foldl divide 1 [1,2,3,4,5]
8.333333333333333e-3

λ foldr (/) 1 [1,2,3,4,5]
1.875
λ foldr divide 1 [1,2,3,4,5]
1.875
```

```haskell
λ foldr divide 1 [2,3,4,5]
0.5333333333333333
λ 1 `divide` 2 `divide` 3 `divide` 4 `divide` 5
1.875
-- because
2 `divide` 3 `divide` 4 `divide` 5 `divide` 1 -- is what foldr does
```

1. The l in foldl stands for left associative.
2. In a left fold, the initial value is applied first, at the left-hand side of the unrolled expression.
3. In a left fold the accumulator value is the first (left) argument of the function you pass in.
4. The r in foldr stands for right associative.
5. In a right fold, the initial value is applied last, at the right-hand side of an unrolled expression.
6. In a right fold, the accumulator is the second (right) argument of the function that you pass in.

## Transforming List Elements
Example of applying `map` function to a list:
```haskell
λ let incr x = x + 1 in map incr [1..3]
[2,3,4]
λ map (+ 2) [1..3]
[3,4,5]
λ map ($ 10) [(+ 1), (* 3), (`div` 5)]
[11,30,2]
```
Example of custom map function:
```haskell
doubleElements :: [Int] -> [Int]
doubleElements nums =
  if null nums
    then []
    else
      let
        hd = head nums
        tl = tail nums
       in
        (2 * hd) : doubleElements tl

doubleElements' numbers = foldr doubleElement [] where doubleElement number lst = (number * 2) : lst

doubleElements'' elems = foldr (applyElem (* 2)) [] elems
 where
  applyElem f elem accumulator = f elem : accumulator

map' f = foldr (applyElem f) []
 where
  applyElem f elem accumulator = (f elem) : accumulator
doubleElements''' elems = map' (* 2) elems

map'' f xs =
  if null xs
    then []
    else f (head xs) : map'' f (tail xs)
```

## Filtering List Elements
```haskell
λ foldr (+) 0 $ filter odd [1..10]
25
λ (foldr (+) 0 . filter odd) [0..10]
25
```

Example of food cost for friends:
```haskell
-- returns True if name in guestList
checkGuestList guestList name =
  name `elem` guestList
foodCosts =
  [("Ren", 10.00)
  ,("George", 4.00)
  ,("Porter", 27.50)]
partyBudget isAttending =
  foldr (+) 0 . map snd . filter (isAttending . fst)
-- foodCosts is eta-reduced
λ partyBudget (checkGuestList ["Ren","Porter"]) foodCosts
37.5
```

## Building Lists with Comprehensions
```haskell
double = [2 * number | number <- [0..10]]
doubleOdds = [2 * number | number <- [0..10], odd number]
doubleOdds = map (\number -> 2 * number) . filter odd $ [0..10] -- or (map ... . filter odd) [0..10]
```
Where list comprehensions start to really shine is when you have several lists that you want to work with, and many different filters. Let’s start with an illustrative example by building a function that will take two lists of numbers and will return a list of pairs of elements in the first list that are also in the second list, paired with odd elements of the second list. We’ll start by implementing this without using a list comprehension:
```haskell
pairs as bs =
  let as' = filter (`elem` bs) as
      bs' = filter odd bs
      mkPairs a = map (\b -> (a, b)) bs'
   in concat $ map mkPairs as'
λ pairs [1..10] [2..5]
[(2,3),(2,5),(3,3),(3,5),(4,3),(4,5),(5,3),(5,5)]

pairs' as bs =
  [(a, b) | a <- as, b <- bs, a `elem` bs, odd b]
```

To better see how we might make use of list comprehensions in practice, let’s go back to our dinner party budgeting function and imagine we wanted to expand it to account for the fact that most guests may want to eat more than one dish. Instead of including a price for the guest’s favorite meal, we’ll instead get a list of a guest and the food they’ve requested. We’ll also take two new functions. First, willEat will take a guest’s name and a food, and will return true if the guest might want to eat that food. Second, foodCost will take a food and return its price. To calculate our budget now, we want to go through the list of all the guests that are attending and, for each food that we’ll be serving, add the cost for that food if the guest might eat it. Building this as a simple pipeline with map, filter, and fold could get quite complicated, but as you’ve just learned we can use list comprehensions to help simplify these types of functions. Using a list comprehension we can tersely express our new party budget calculator:
```haskell
partyBudget' isAttending willEat foodCost guests =
  foldl (+) 0 $
    [ foodCost food
    | guest <- map fst guests
    , food <- map snd guests
    , willEat guest food
    , isAttending guest
    ]
```

```haskell
zip' as bs =
  let
    a = head as
    b = head bs
    as' = tail as
    bs' = tail bs
   in
    if null as || null bs
      then []
      else (a, b) : combineLists as' bs'
```

Example of pairwise sum:
```haskell
pairwiseSum xs ys =
  let sumElems pairs =
    let a = fst pairs
        b = snd pairs
    in a + b
  in map sumElems $ zip xs ys
-- or
pairwiseSum xs ys = map (uncurry (+)) $ zip xs ys
```

## Destructuring values with pattern matching
As you learned earlier in this chapter, a `partial` function is one that doesn’t handle all of the possible input values it could get, and a `total` function is one that does handle all possible inputs. Example of matching "George":
```haskell
customGreeting "George" = "Oh, hey George!"
customGreeting name = "Hello, " <> name

-- will never reach the second one as the first is complete
customGreeting name = "Hello, " <> name
customGreeting "George" = "Oh, hey George!"

-- can also be used with all the primitives and also lists and tuples
customGreeting ["George"] = ...
customGreeting ("George") = ...

-- multiple multi-parameter match
matchTuple ("hello", "world") = "Hello there, you great big world"
matchTuple ("hello", name) = "Oh, hi there, " <> name
matchTuple (salutation, "George") = "Oh! " <> salutation <> " George!"
matchTuple n = show n
```

## Destructuring Lists
Up until now, if you wanted to write a function that used elements from a list, you would often end up writing the same boilerplate code that would:
1. Check to see if the current list is empty (and if so return some base value),
2. Use the head function to get the first element of the list,
3. Use the tail function to get the rest of the list,
4. Possibly do some computation with the head of the list, and
5. Make a recursive call with the tail of the list.

```haskell
addValues [] = 0
addValues (first:rest) = first + (addValues rest)
```

You can also use pattern matching outside of the parameters of a function. One useful place to use pattern matching is in let bindings. Imagine that you have a function, fancyNumbers, which given some number, n, gives you back the nth Fibonacci number and the nth prime number:
```haskell
λ fancyNumbers n = (zip fibs primes) !! n
-- n is applied via !! to both fibs and primes as index element
λ fancyNumbers 27
(317811,103)

printFancy n =
  let (fib, prime) = fancyNumbers n
    fibonacci = show fib
    prime' = show prime
  in "The fibonacci number is: " <> fib' <> " and the prime is: " <> prime'
```

In some cases you want to pattern match, but also get the original value that hasn’t been deconstructed. You can do that by adding a variable before your pattern followed by an @ symbol. As an example, try copying in the following function that will accept a pair and replace the first or second elements if they match some special case, and otherwise will return the original pair:
```haskell
modifyPair p@(a, b)
  | a == "Hello" = "this is a salutation"
  | b == "George" = "this is a message for George"
  | otherwise = "I don't know what " <> show p <> " means"

λ modifyPair ("Hello", "George")
"this is a salutation" -- wins first
λ modifyPair ("What's going on", "George")
"this is a message for George" -- then second
λ modifyPair ("this is", "a message")
"I don't know what (\"this is\",\"a message\") means" -- then n-th
```

A special pattern that you can use is the wildcard pattern. To use a wildcard pattern, use an underscore instead of a value or variable name:
```haskell
fst (x, _, _) = x
snd (_, x, _) = x
thrd (_, _, x) = x
λ map ($ (1,2,3)) [fst, snd, thrd]
[1,2,3]
```

Can also be used to incdicate a variable that is there but not needed:
```haskell
printHead [] = "empty!"
printHead lst@(hd : _tail) =
  "the head of " <> (show lst) <> " is " <> show hd
```

Example of `case` syntax which more of a sugar:
```haskell
favoriteFood person =
  case person of
    "ren" -> "tofu"
    "rebecca" -> "falafel"
    name -> "i don't know what " <> name <> " likes!"
    "George" -> "Banana"
```
Another one:
```haskell
handleNums l =
  case l of
    [] -> "An empty list"
    [x]
      | x == 0 -> "a list called: [0]"
      | x == 1 -> "a singular list of [1]"
      | even x -> "a singleton list containing an even number"
      | otherwise -> "the list contains " <> (show x)
    _list -> "the list has more than 1 element"
```

## Getting Warned About Incomplete Patterns
Example of throwing an error in incomplete pattern:
```haskell
partialFunction 0 = "I only work for 0"
partialFunction impossibleValue = error $
  "I only work with 0 but I was called with " <> show impossibleValue
```
To enable errors in compiler do `ghc -Wincomplete-patterns`
To enable errors in interactive compiler do `ghci -Wincomplete-patterns` or `set -Wincomplete-patterns`

