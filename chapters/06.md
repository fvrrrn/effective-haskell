Chapter 6

## Creating And Structuring Haskell Projects

Object-oriented programming languages let you solve this problem using inheritance or interfaces to write different implementations of functions depending on their type. The idea that we can provide a different implementation of a function depending on its type is called ad hoc polymorphism. Haskell provides its own approach to ad hoc polymorphism with type classes

## Using Ad Hoc Polymorphism with Type classes

```haskell
data Natural a = Natural
  { equal :: a -> a -> Bool,
    add :: a -> a -> a,
    multiply :: a -> a -> a,
    additiveIdentity :: a,
    multiplicativeIdentity :: a,
    displayAsString :: a -> String
  }

intNatural :: Natural Int
intNatural =
  Natural
    { equal = (==),
      add = (+),
      multiply = (*),
      additiveIdentity = 0,
      multiplicativeIdentity = 1,
      displayAsString = show
    }

data Peano = Z | S Peano

toPeano :: Int -> Peano
toPeano 0 = Z
toPeano n = S $ toPeano (n - 1)

fromPeano :: Peano -> Int
fromPeano Z = 0
fromPeano (S n) = 1 + fromPeano n

peanoNatural :: Natural Peano
peanoNatural =
  Natural
    { equal = comparePeano,
      add = addPeano,
      multiply = multiplyPeano,
      -- In mathematics, the additive identity of a set that is equipped with the operation of addition is an element which, when added to any element x in the set, yields x. One of the most familiar additive identities is the number 0 from elementary mathematics, but additive identities occur in other mathematical structures where addition is defined, such as in groups and rings.
      additiveIdentity = Z,
      -- Multiplicative identity. noun. : an element of a set that when multiplied by any other element of the set leaves the element unchanged.
      multiplicativeIdentity = S Z,
      displayAsString = show . fromPeano
    }
  where
    comparePeano Z Z = True
    comparePeano (S a) (S b) = comparePeano a b
    comparePeano _ _ = False
    addPeano Z b = b
    addPeano (S a) b = addPeano a (S b)
    multiplyPeano Z _ = Z
    multiplyPeano (S a) b =
      addPeano b (multiplyPeano a b)
```

## Creating a Type Class for Natural

```haskell
class Natural n where
  equal :: n -> n -> Bool
  add :: n -> n -> n
  multiply :: n -> n -> n
  additiveIdentity :: n
  multiplicativeIdentity :: n
  displayAsString :: n -> String

instance Natural Int where
  equal = (==)
  add = (+)
  multiply = (*)
  additiveIdentity = 0
  multiplicativeIdentity = 1
  displayAsString = show
```
